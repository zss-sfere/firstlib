#include "User_Config.h"

typedef long long  s64;

const s16 COS_TAB[128]=
{
	16384, 
	16365, 
	16306, 
	16207, 
	16070, 
	15893, 
	15679, 
	15427, 
	15137, 
	14811, 
	14450, 
	14053, 
	13623, 
	13160, 
	12665, 
	12140, 
	11586, 
	11003, 
	10394, 
	9760, 
	9103, 
	8423, 
	7724, 
	7005, 
	6270, 
	5520, 
	4756, 
	3981, 
	3197, 
	2404, 
	1606, 
	804, 
	0, 
	-804, 
	-1606, 
	-2404, 
	-3196, 
	-3981, 
	-4756, 
	-5519, 
	-6269, 
	-7005, 
	-7723, 
	-8423, 
	-9102, 
	-9760, 
	-10393, 
	-11002, 
	-11585, 
	-12139, 
	-12665, 
	-13159, 
	-13622, 
	-14053, 
	-14449, 
	-14811, 
	-15136, 
	-15426, 
	-15678, 
	-15893, 
	-16069, 
	-16206, 
	-16305, 
	-16364, 
	-16384, 
	-16364, 
	-16305, 
	-16206, 
	-16069, 
	-15893, 
	-15678, 
	-15426, 
	-15136, 
	-14811, 
	-14449, 
	-14053, 
	-13622, 
	-13159, 
	-12665, 
	-12139, 
	-11585, 
	-11002, 
	-10393, 
	-9760, 
	-9102, 
	-8423, 
	-7723, 
	-7005, 
	-6269, 
	-5519, 
	-4756, 
	-3981, 
	-3196, 
	-2404, 
	-1606, 
	-804, 
	0, 
	804, 
	1606, 
	2404, 
	3197, 
	3981, 
	4756, 
	5520, 
	6270, 
	7005, 
	7724, 
	8423, 
	9103, 
	9760, 
	10394, 
	11003, 
	11586, 
	12140, 
	12665, 
	13160, 
	13623, 
	14053, 
	14450, 
	14811, 
	15137, 
	15427, 
	15679, 
	15893, 
	16070, 
	16207, 
	16306, 
	16365,	
};

//正弦表
const s16 SIN_TAB[128] =
{
	0, 
	804, 
	1606, 
	2404, 
	3197, 
	3981, 
	4756, 
	5520, 
	6270, 
	7005, 
	7724, 
	8423, 
	9103, 
	9760, 
	10394, 
	11003, 
	11586, 
	12140, 
	12665, 
	13160, 
	13623, 
	14053, 
	14450, 
	14811, 
	15137, 
	15427, 
	15679, 
	15893, 
	16070, 
	16207, 
	16306, 
	16365, 
	16384, 
	16365, 
	16306, 
	16207, 
	16070, 
	15893, 
	15679, 
	15427, 
	15137, 
	14811, 
	14450, 
	14053, 
	13623, 
	13160, 
	12665, 
	12140, 
	11586, 
	11003, 
	10394, 
	9760, 
	9103, 
	8423, 
	7724, 
	7005, 
	6270, 
	5520, 
	4756, 
	3981, 
	3197, 
	2404, 
	1606, 
	804, 
	0, 
	-804, 
	-1606, 
	-2404, 
	-3196, 
	-3981, 
	-4756, 
	-5519, 
	-6269, 
	-7005, 
	-7723, 
	-8423, 
	-9102, 
	-9760, 
	-10393, 
	-11002, 
	-11585, 
	-12139, 
	-12665, 
	-13159, 
	-13622, 
	-14053, 
	-14449, 
	-14811, 
	-15136, 
	-15426, 
	-15678, 
	-15893, 
	-16069, 
	-16206, 
	-16305, 
	-16364, 
	-16384, 
	-16364, 
	-16305, 
	-16206, 
	-16069, 
	-15893, 
	-15678, 
	-15426, 
	-15136, 
	-14811, 
	-14449, 
	-14053, 
	-13622, 
	-13159, 
	-12665, 
	-12139, 
	-11585, 
	-11002, 
	-10393, 
	-9760, 
	-9102, 
	-8423, 
	-7723, 
	-7005, 
	-6269, 
	-5519, 
	-4756, 
	-3981, 
	-3196, 
	-2404, 
	-1606, 
	-804, 
};

const s16 Tab_THHF_NxPn[48] = 
{
//0,
//0,       //0.71
18,      //17.82
107,     //106.5
356,     //356.4
895,
1770,
2632,
3872,
5238,
6610,
8063,
9528,
11063,
12628,
14325,
16000,
17595,
19296,
21071,
22240,
23289,
23584,
23805,
24000,
24425,
24830,
25083,
25340,
25259,
25830,
26102,
26368,
26631,
26894,
27125,
27360,
27565,
27816,
28080,
28320,
28618,
28938,
29197,
29480,
29745,
29992,
30221,
30432,
30625,
};


/*********************************
整数绝对值
*********************************/
u16 abss16(s16 p)
{
	if(p<0) p = -p;
	return ((u16)p);
}

u32 abss32(s32 p)
{
	if(p<0) p = -p;
	return((u32)p);	
}

u8 HexToBcdChar(u8 p)
{
	u8 bcd=0;
	bcd |= ((p%100/10)<<4);			//十
	bcd |= (p%10);					//个
	return(bcd);
}


/*
**=========================================================================
** 函数名称: MySqrt32(u32 M)
** 功能    : 32位无符号开放运算(正形平方根近似算法)
**=========================================================================
*/
u16 MySqrt32(u32 M)
{
  u16 N, i;
  u32 tmp, ttp;   // 结果、循环计数
  if (M == 0)               // 被开方数，开方结果也为0
  return 0;
  N = 0;
  tmp = (M >> 30);          // 获取最高位：B[m-1]
  M <<= 2;
  if (tmp > 1)              // 最高位为1
  {
    N ++;                   // 结果当前位为1，否则为默认的0
    tmp -= N;
  }
  for (i=15; i>0; i--)      // 求剩余的15位
  {
    N <<= 1;                // 左移一位
    tmp <<= 2;
    tmp += (M >> 30);       // 假设
    ttp = N;
    ttp = (ttp<<1)+1;
    M <<= 2;
    if (tmp >= ttp)         // 假设成立
    {
      tmp -= ttp;
      N ++;
    }
  }
  return N;
}

/*
**=========================================================================
** 函数名称: s16 sin16384(u16 angle)
** 功    能: 定点数正弦函数
** 参    数: angle    0-3599 分辨率为0.1度
** 返回值  : 返回值已经 x16384
** 公    式: y = (a*x +_ b*x^2 + c*x^3 + d*x^4 + e*x^5)/16384  
**               a = +25728
**               b = +89
**               c = -10931
**               d = +594
**               e = +904
**               x = 0-1  (对应0-90度) 
**               0-90度  sin(x)
**             90-180度  sin(x) = sin(180.0-x)
**            180-270度  sin(x) = -sin(x-180.0)
**            270-360度  sin(x) = -sin(360.0-x)
**=========================================================================
*/
s16 Sinu16(u16 angle)
{
  u16 Q;
  u16 SIN = 0;
  s32 temp32 = 0;
  long long QXQ;
  
  if(angle<=900) Q = angle;
  else if(angle<=1800) Q = (u16)(1800 - angle);
  else if(angle<=2700) Q = (u16)(angle - 1800);
  else if(angle<=3600) Q = (u16)(3600 - angle);
  else return SIN;
  
  temp32 = 25728*Q/900;
  QXQ = Q*Q;
  temp32 += QXQ*89/810000;
  temp32 -= QXQ*Q*10931/729000000;
  temp32 += QXQ*QXQ*594/656100000000;
  temp32 += QXQ*QXQ*Q*904/590490000000000; 
  
  if(angle<=1800) SIN = (s16)temp32;
  else SIN = (s16)(-temp32);
  return SIN;
}

/*
**=========================================================================
** 函数名称: s16 cos16384(u16 ang3600)
** 功    能: 定点数余弦函数
** 参    数: ang3600    0-3599 分辨率为0.1度
** 返回值  : 返回值已经 x16384          

**=========================================================================
*/
s16 Cosu16(u16 angle)
{
  if(angle<2700) return Sinu16((u16)(angle+900));
  else return Sinu16((u16)(angle-2700)); 
}



///*****************************************
//Name: s16 MaxInt16_p(s16 *p,s16 n)
//Function: 查询最大值
//*****************************************/
s16 MaxInt16_p(s16 *p,s16 n)
{
  u16 i;
  s16 max = *p;
  for(i=0;i<n;i++)
  {
    if(*p>max) max = *p;
    p++;  
  }
  return max;
}


/**********************************************
Name: void Delayus(u16 time)
Function: 主频72M ，延时1us
Input： time -> 延时长度 time us 
Output: None
**********************************************/
void Delayus(u16 time)
{
	u8 i = 0;
	while(time--)
	{
		i = 10;
		while(i--);	
	}
}

/***************************************************
Name: void Delayms(u16 time)
Function: 主频72M， 延时1ms
Input: time -> 延时长度 time ms
***************************************************/
void Delayms(u16 time)
{
	u16 i;
	while(time--)
	{
		i = 12000;
		while(i--);	
	}	
}



/*****************************************************
Name: void MyFFT(s32dataR[NUM_FFT], s32 dataI[NUM_FFT])
Function: 谐波FFT分析
Input: dataR[NUM_FFT]:采样点， dataI[NUM_FFT]:需数点
******************************************************/
void MyFFT(s32 dataR[NUM_FFT], s32 dataI[NUM_FFT])
{
	s16 x0,x1,x2,x3,x4,x5,x6,xx;
	s16 i,j,k,b,p,L;
	s32 TR,TI,temp;
	//翻转序列
	for(i=0; i<NUM_FFT; i++)
	{
		x0=x1=x2=x3=x4=x5=x6=0; 
		x0=i&0x01; x1=(i/2)&0x01; x2=(i/4)&0x01; x3=(i/8)&0x01;
		x4=(i/16)&0x01; x5=(i/32)&0x01; x6=(i/64)&0x01;
		xx = x0*64+x1*32+x2*16+x3*8+x4*4+x5*2+x6;
		dataI[xx] = dataR[i];	
	}
	//防止不能及时初始化接收状态
	if(TASK_START[0]&Tab_32bit[0][BIT_USART3]) TaskUsart3(); //通信1
	if(TASK_START[0]&Tab_32bit[0][BIT_USART3TX]) Usart3TxInit(); 
		
	//得到翻转后的序列
	for(i=0; i<NUM_FFT; i++)
	{
		dataR[i] = dataI[i];
		dataI[i] = 0;	
	}

	/************** following code FFT *******************/
	for ( L=1;L<=7;L++ )
	{ /* for(1) */
		b=1; 
		i=L-1;
		while(i>0)
		{
			b = b*2;
			i--;	
		}
		for ( j=0;j<=b-1;j++ ) /* for (2) */
		{
			//防止不能及时初始化接收状态
			if(TASK_START[0]&Tab_32bit[0][BIT_USART3]) TaskUsart3(); //通信1
			if(TASK_START[0]&Tab_32bit[0][BIT_USART3TX]) Usart3TxInit(); 
			
			p=1; 
			i=7-L;
			while(i>0)
			{
				p=p*2; 
				i--;	
			}
			p=p*j;
			for ( k=j;k<=127;k=k+2*b ) /* for (3) */
			{
				TR=dataR[k]; TI=dataI[k]; temp=dataR[k+b];
				dataR[k]=(s32)(dataR[k]+((((s64)dataR[k+b])*COS_TAB[p]+((s64)dataI[k+b])*SIN_TAB[p])>>14));
				dataI[k]=(s32)(dataI[k]-((((s64)dataR[k+b])*SIN_TAB[p]-((s64)dataI[k+b])*COS_TAB[p])>>14));
				dataR[k+b]=(s32)(TR-((((s64)dataR[k+b])*COS_TAB[p]+((s64)dataI[k+b])*SIN_TAB[p])>>14));
				dataI[k+b]=(s32)(TI+((((s64)temp)*SIN_TAB[p]-((s64)dataI[k+b])*COS_TAB[p])>>14));
			} /* END for (3) */
		} /* END for (2) */
	} /* END for (1) */
	

} /* END FFT */


/*
**=========================================================================
** 函数名称: SqrtWithMul(u32 m)
** 功能    : 32位无符号开放运算(乘法比较算法)
**=========================================================================
*/
u16 SqrtWithMul(u32 m)
{
	u16	n=0x0000;
	if(0x40000000<=m) n|=0x8000;
	if((u32)(n|0x4000)*(n|0x4000)<=m) n|=0x4000;
	if((u32)(n|0x2000)*(n|0x2000)<=m) n|=0x2000;
	if((u32)(n|0x1000)*(n|0x1000)<=m) n|=0x1000;
	if((u32)(n|0x0800)*(n|0x0800)<=m) n|=0x0800;
	if((u32)(n|0x0400)*(n|0x0400)<=m) n|=0x0400;
	if((u32)(n|0x0200)*(n|0x0200)<=m) n|=0x0200;
	if((u32)(n|0x0100)*(n|0x0100)<=m) n|=0x0100;
	if((u32)(n|0x0080)*(n|0x0080)<=m) n|=0x0080;
	if((u32)(n|0x0040)*(n|0x0040)<=m) n|=0x0040;
	if((u32)(n|0x0020)*(n|0x0020)<=m) n|=0x0020;
	if((u32)(n|0x0010)*(n|0x0010)<=m) n|=0x0010;
	if((u32)(n|0x0008)*(n|0x0008)<=m) n|=0x0008;
	if((u32)(n|0x0004)*(n|0x0004)<=m) n|=0x0004;
	if((u32)(n|0x0002)*(n|0x0002)<=m) n|=0x0002;
	if((u32)(n|0x0001)*(n|0x0001)<=m) n|=0x0001;
	return n;
}

/*
根据谐波的次数进行改变循环次数              ______________________________
THFF = 1/Urms * / E (Kn*Pn*Uthdn)x(Kn*Pn*Uthdn)             n 1- 31
*/
//计算电话谐波波形系数
u16 THHD_Un(u16 n,u16 Hz)
{
  s16 THFF = 0;
  u16 i,j;
  u32 m;
  m = 50;
  for(i=0;i<29;i++) //从2次开始
  {
    j = (u16)((u32)Tab_THHF_NxPn[i]*HarmonicData[i][n]/1000);
    m += j*j;  
  }
  i = SqrtWithMul(m);
  j = SqrtWithMul(1000000 + (u32)MeterQuality.UTHD[n]*MeterQuality.UTHD[n]/100);
  THFF = (u16)(Hz*i/j/80);
  return THFF;
}

u8 MaxInt8_p(u8 *p, u8 n)
{
  u8 i;
  u8 max = *p;
  OxAddr = 0;
  for(i=0;i<n;i++)
  {
    if(*p>max) 
    {
    	max = *p;
    	OxAddr = i;
    }
    p++;  
  }
  return max;	
}
